\documentclass[11pt]{article}
\usepackage[a4paper,margin=1in]{geometry}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{siunitx}
\usepackage{enumitem}
\title{Towards a New Hutter Prize Record on enwik9: System Design and Implementation}
\author{HutterPrize Solver Authors}
\date{\today}
\begin{document}
\maketitle
\begin{abstract}
We fix a critical correctness bug in the reversible transform layer caused by a dictionary token ID skew between encoder and decoder. The dictionary is centralized in a shared header and de-duplicated, and the HPZT payload header is upgraded to version 2 with a dictionary checksum guard that the decoder verifies before decoding. The pipeline remains a self-extracting archive with streaming transforms (dictionary, space/newline runs, digit runs) and a zlib backend (STORE fallback). We add a binary-safe transform selftest that stresses chunk boundaries and escape sequences to guard against regressions. This establishes a correct baseline for future backend upgrades toward record competitiveness.
\end{abstract}

\section{Self-Extracting Format}
We concatenate a decompressor stub with a payload and an HPZ2 footer (magic, method byte, original size, payload size, CRC-32 of original). When transforms are enabled, the payload starts with an HPZT header. We now use version~2 (``HPZT'') consisting of magic, version, flags, two reserved bytes, and a 32-bit checksum of the shared dictionary. The decoder validates the checksum before transform decoding, preventing encoder/decoder skew. Version~1 headers (8 bytes without checksum) remain supported for backward compatibility.

\section{Transforms}
\begin{itemize}[noitemsep]
  \item Dictionary tokenization: frequent XML/Wikitext substrings are replaced by two-byte tokens (0x00, id).
  \item Space-run encoding: runs of spaces of length $\ge 4$ are replaced by 0x00, 0x80, len$-$4.
  \item Newline-run encoding: runs of newlines of length $\ge 2$ are replaced by 0x00, 0x81, len$-$2.
  \item Digit-run encoding: runs of digits of length $\ge 3$ are replaced by 0x00, 0x82, len$-$3 followed by the digit bytes.
  \item Escape: literal 0x00 is encoded as 0x00, 0x00.
\end{itemize}
All transforms are streaming and strictly invertible; decoding uses a small FSM.

\section{Binary-Safe Selftests and Boundary Coverage}
We implement a self-contained C++ selftest that constructs HPZT v2 payloads and verifies binary-exact decoding across multiple chunk splits, including cases where token and length bytes straddle buffer boundaries. The tests cover literal 0x00 escapes, dictionary tokens, and space/newline/digit runs, and emit hex dumps on failure to precisely locate issues. The selftest runs before large downloads in the verification script to provide rapid feedback during development.

\section{Compression Backend and CLI}
We use dynamic zlib (loaded at runtime) when available and fall back to STORE otherwise. The compressor supports \texttt{--method=zlib|store} and \texttt{--no-transform} for ablations.

\section{Roadmap}
Next iterations will integrate a stronger context-mixing backend and expand reversible transforms (structural tagging, numeric/date canonicalization) while maintaining strict reversibility and single-binary decoding.

\end{document}
