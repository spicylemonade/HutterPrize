#!/usr/bin/env bash
set -euo pipefail

# Generate docs/results.tex and docs/results.json from current artifacts
# Uses tools/sizer.py for size calculations; attempts SHA-1 if available.

COMP=${COMP:-comp}
ARCHIVE=${ARCHIVE:-archive}
ENWIK9=${ENWIK9:-enwik9}
OUTDIR=${OUTDIR:-decompress_out}
OUT_CAND1=${OUT_CAND1:-enwik9}
OUT_CAND2=${OUT_CAND2:-enwik9.out}
DOCSDIR=${DOCSDIR:-docs}
RESULTS_TEX="$DOCSDIR/results.tex"
RESULTS_JSON="$DOCSDIR/results.json"

mkdir -p "$DOCSDIR"

size_json='{}'
if [[ -x tools/sizer.py && -f "$COMP" && -f "$ARCHIVE" ]]; then
  size_json=$(tools/sizer.py --json "$COMP" "$ARCHIVE")
fi

get_json_field() {
  # usage: get_json_field FIELD_NAME
  # Very small Python helper to avoid jq dependency
  local field="$1"
  python3 - "$field" << 'PY'
import json, sys
s = sys.stdin.read()
try:
    data = json.loads(s)
except Exception:
    data = {}
key = sys.argv[1]
val = data.get(key, '')
print(val)
PY
}

S1=$(printf '%s' "$size_json" | get_json_field S1)
S2=$(printf '%s' "$size_json" | get_json_field S2)
S=$(printf '%s' "$size_json" | get_json_field S)
L=$(printf '%s' "$size_json" | get_json_field L)
L1=$(printf '%s' "$size_json" | get_json_field L_1pct)
PASS_REC=$(printf '%s' "$size_json" | get_json_field pass_record)
PASS_PCT=$(printf '%s' "$size_json" | get_json_field pass_prize_1pct)

sha_cmd=""
if command -v sha1sum >/dev/null 2>&1; then sha_cmd=sha1sum; fi
if [[ -z "$sha_cmd" && $(command -v shasum >/dev/null 2>&1; echo $?) -eq 0 ]]; then sha_cmd="shasum -a 1"; fi

sha_enwik9="N/A"
[[ -f "$ENWIK9" && -n "$sha_cmd" ]] && sha_enwik9=$(eval "$sha_cmd \"$ENWIK9\"" | awk '{print $1}')

OUTFILE=""
if [[ -f "$OUTDIR/$OUT_CAND1" ]]; then OUTFILE="$OUTDIR/$OUT_CAND1"; fi
if [[ -z "$OUTFILE" && -f "$OUTDIR/$OUT_CAND2" ]]; then OUTFILE="$OUTDIR/$OUT_CAND2"; fi

sha_out="N/A"
[[ -n "$OUTFILE" && -n "$sha_cmd" ]] && sha_out=$(eval "$sha_cmd \"$OUTFILE\"" | awk '{print $1}')

uname_s=$(uname -s 2>/dev/null || echo unknown)
uname_r=$(uname -r 2>/dev/null || echo unknown)
uname_m=$(uname -m 2>/dev/null || echo unknown)

cat > "$RESULTS_JSON" <<JSON
{
  "comp": "$COMP",
  "archive": "$ARCHIVE",
  "S1": ${S1:-0},
  "S2": ${S2:-0},
  "S": ${S:-0},
  "L": ${L:-110793128},
  "L_1pct": ${L1:-109685196},
  "pass_record": ${PASS_REC:-false},
  "pass_prize_1pct": ${PASS_PCT:-false},
  "sha1_enwik9": "${sha_enwik9}",
  "sha1_out": "${sha_out}",
  "out_file": "${OUTFILE}",
  "system": {
    "uname_s": "${uname_s}",
    "uname_r": "${uname_r}",
    "uname_m": "${uname_m}"
  }
}
JSON

cat > "$RESULTS_TEX" <<TEX
% Auto-generated by scripts/report.sh
\section*{Automated Results Summary}

\noindent\textbf{Binary sizes}\\
S1 (comp): ${S1:-0} bytes\\
S2 (archive): ${S2:-0} bytes\\
S total: ${S:-0} bytes\\
Record to beat (L): ${L:-110793128}\\
\mbox{\(\geq\)1\% target}: ${L1:-109685196}\\
Status vs record: ${PASS_REC:-false}\\
Status vs \(\geq\)1\%: ${PASS_PCT:-false}\\

\noindent\textbf{Integrity (optional)}\\
SHA-1 enwik9: ${sha_enwik9}\\
SHA-1 output: ${sha_out}\\
Output file: ${OUTFILE:-N/A}\\

\noindent\textbf{System}\ (uname): ${uname_s} ${uname_r} ${uname_m}
TEX

echo "[report] Wrote $RESULTS_TEX and $RESULTS_JSON"
